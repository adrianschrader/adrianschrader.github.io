import{r as J,g as B}from"./index-DW7Z2t5A.js";const K={},L=r=>{let n;const i=new Set,c=(v,$)=>{const s=typeof v=="function"?v(n):v;if(!Object.is(s,n)){const y=n;n=$??typeof s!="object"?s:Object.assign({},n,s),i.forEach(A=>A(n,y))}},o=()=>n,d={setState:c,getState:o,subscribe:v=>(i.add(v),()=>i.delete(v)),destroy:()=>{(K?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),i.clear()}};return n=r(c,o,d),d},Q=r=>r?L(r):L;var H={exports:{}},V={},b={exports:{}},F={};/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var C=J;function Z(r,n){return r===n&&(r!==0||1/r===1/n)||r!==r&&n!==n}var j=typeof Object.is=="function"?Object.is:Z,tt=C.useState,et=C.useEffect,nt=C.useLayoutEffect,rt=C.useDebugValue;function ot(r,n){var i=n(),c=tt({inst:{value:i,getSnapshot:n}}),o=c[0].inst,S=c[1];return nt(function(){o.value=i,o.getSnapshot=n,R(o)&&S({inst:o})},[r,i,n]),et(function(){return R(o)&&S({inst:o}),r(function(){R(o)&&S({inst:o})})},[r]),rt(i),i}function R(r){var n=r.getSnapshot;r=r.value;try{var i=n();return!j(r,i)}catch{return!0}}function it(r,n){return n()}var st=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?it:ot;F.useSyncExternalStore=C.useSyncExternalStore!==void 0?C.useSyncExternalStore:st;b.exports=F;var ut=b.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var I=J,at=ut;function ct(r,n){return r===n&&(r!==0||1/r===1/n)||r!==r&&n!==n}var ft=typeof Object.is=="function"?Object.is:ct,dt=at.useSyncExternalStore,lt=I.useRef,pt=I.useEffect,vt=I.useMemo,yt=I.useDebugValue;V.useSyncExternalStoreWithSelector=function(r,n,i,c,o){var S=lt(null);if(S.current===null){var T={hasValue:!1,value:null};S.current=T}else T=S.current;S=vt(function(){function v(h){if(!$){if($=!0,s=h,h=c(h),o!==void 0&&T.hasValue){var E=T.value;if(o(E,h))return y=E}return y=h}if(E=y,ft(s,h))return E;var p=c(h);return o!==void 0&&o(E,p)?E:(s=h,y=p)}var $=!1,s,y,A=i===void 0?null:i;return[function(){return v(n())},A===null?void 0:function(){return v(A())}]},[n,i,c,o]);var d=dt(r,S[0],S[1]);return pt(function(){T.hasValue=!0,T.value=d},[d]),yt(d),d};H.exports=V;var ht=H.exports;const St=B(ht),mt={},{useSyncExternalStoreWithSelector:gt}=St;function Et(r,n=r.getState,i){const c=gt(r.subscribe,r.getState,r.getServerState||r.getState,n,i);return J.useDebugValue(c),c}const z=r=>{(mt?"production":void 0)!=="production"&&typeof r!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const n=typeof r=="function"?Q(r):r,i=(c,o)=>Et(n,c,o);return Object.assign(i,n),i},_t=r=>r?z(r):z,O={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1},x=new Map,P=r=>{const n=x.get(r);return n?Object.fromEntries(Object.entries(n.stores).map(([i,c])=>[i,c.getState()])):{}},wt=(r,n,i)=>{if(r===void 0)return{type:"untracked",connection:n.connect(i)};const c=x.get(i.name);if(c)return{type:"tracked",store:r,...c};const o={connection:n.connect(i),stores:{}};return x.set(i.name,o),{type:"tracked",store:r,...o}},$t=(r,n={})=>(i,c,o)=>{const{enabled:S,anonymousActionType:T,store:d,...v}=n;let $;try{$=(S??(O?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!$)return(O?"production":void 0)!=="production"&&S&&console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension"),r(i,c,o);const{connection:s,...y}=wt(d,$,v);let A=!0;o.setState=(p,g,l)=>{const _=i(p,g);if(!A)return _;const D=l===void 0?{type:T||"anonymous"}:typeof l=="string"?{type:l}:l;return d===void 0?(s==null||s.send(D,c()),_):(s==null||s.send({...D,type:`${d}/${D.type}`},{...P(v.name),[d]:o.getState()}),_)};const h=(...p)=>{const g=A;A=!1,i(...p),A=g},E=r(o.setState,c,o);if(y.type==="untracked"?s==null||s.init(E):(y.stores[y.store]=o,s==null||s.init(Object.fromEntries(Object.entries(y.stores).map(([p,g])=>[p,p===y.store?E:g.getState()])))),o.dispatchFromDevtools&&typeof o.dispatch=="function"){let p=!1;const g=o.dispatch;o.dispatch=(...l)=>{(O?"production":void 0)!=="production"&&l[0].type==="__setState"&&!p&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),p=!0),g(...l)}}return s.subscribe(p=>{var g;switch(p.type){case"ACTION":if(typeof p.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return q(p.payload,l=>{if(l.type==="__setState"){if(d===void 0){h(l.state);return}Object.keys(l.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const _=l.state[d];if(_==null)return;JSON.stringify(o.getState())!==JSON.stringify(_)&&h(_);return}o.dispatchFromDevtools&&typeof o.dispatch=="function"&&o.dispatch(l)});case"DISPATCH":switch(p.payload.type){case"RESET":return h(E),d===void 0?s==null?void 0:s.init(o.getState()):s==null?void 0:s.init(P(v.name));case"COMMIT":if(d===void 0){s==null||s.init(o.getState());return}return s==null?void 0:s.init(P(v.name));case"ROLLBACK":return q(p.state,l=>{if(d===void 0){h(l),s==null||s.init(o.getState());return}h(l[d]),s==null||s.init(P(v.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return q(p.state,l=>{if(d===void 0){h(l);return}JSON.stringify(o.getState())!==JSON.stringify(l[d])&&h(l[d])});case"IMPORT_STATE":{const{nextLiftedState:l}=p.payload,_=(g=l.computedStates.slice(-1)[0])==null?void 0:g.state;if(!_)return;h(d===void 0?_:_[d]),s==null||s.send(null,l);return}case"PAUSE_RECORDING":return A=!A}return}}),E},At=$t,q=(r,n)=>{let i;try{i=JSON.parse(r)}catch(c){console.error("[zustand devtools middleware] Could not parse the received json",c)}i!==void 0&&n(i)};var N={exports:{}};(function(r,n){Object.defineProperty(n,"__esModule",{value:!0});function i(t){return typeof t=="object"&&!("toString"in t)?Object.prototype.toString.call(t).slice(8,-1):t}var c=typeof process=="object"&&!0;function o(t,e){if(!t)throw c?new Error("Invariant failed"):new Error(e())}n.invariant=o;var S=Object.prototype.hasOwnProperty,T=Array.prototype.splice,d=Object.prototype.toString;function v(t){return d.call(t).slice(8,-1)}var $=Object.assign||function(t,e){return s(e).forEach(function(u){S.call(e,u)&&(t[u]=e[u])}),t},s=typeof Object.getOwnPropertySymbols=="function"?function(t){return Object.keys(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.keys(t)};function y(t){return Array.isArray(t)?$(t.constructor(t.length),t):v(t)==="Map"?new Map(t):v(t)==="Set"?new Set(t):t&&typeof t=="object"?$(Object.create(Object.getPrototypeOf(t)),t):t}var A=function(){function t(){this.commands=$({},h),this.update=this.update.bind(this),this.update.extend=this.extend=this.extend.bind(this),this.update.isEquals=function(e,u){return e===u},this.update.newContext=function(){return new t().update}}return Object.defineProperty(t.prototype,"isEquals",{get:function(){return this.update.isEquals},set:function(e){this.update.isEquals=e},enumerable:!0,configurable:!0}),t.prototype.extend=function(e,u){this.commands[e]=u},t.prototype.update=function(e,u){var f=this,a=typeof u=="function"?{$apply:u}:u;Array.isArray(e)&&Array.isArray(a)||o(!Array.isArray(a),function(){return"update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value."}),o(typeof a=="object"&&a!==null,function(){return"update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the "+("following commands: "+Object.keys(f.commands).join(", ")+".")});var m=e;return s(a).forEach(function(w){if(S.call(f.commands,w)){var k=e===m;m=f.commands[w](a[w],m,a,e),k&&f.isEquals(m,e)&&(m=e)}else{var M=v(e)==="Map"?f.update(e.get(w),a[w]):f.update(e[w],a[w]),G=v(m)==="Map"?m.get(w):m[w];(!f.isEquals(M,G)||typeof M>"u"&&!S.call(e,w))&&(m===e&&(m=y(e)),v(m)==="Map"?m.set(w,M):m[w]=M)}}),m},t}();n.Context=A;var h={$push:function(t,e,u){return p(e,u,"$push"),t.length?e.concat(t):e},$unshift:function(t,e,u){return p(e,u,"$unshift"),t.length?t.concat(e):e},$splice:function(t,e,u,f){return l(e,u),t.forEach(function(a){_(a),e===f&&a.length&&(e=y(f)),T.apply(e,a)}),e},$set:function(t,e,u){return X(u),t},$toggle:function(t,e){g(t,"$toggle");var u=t.length?y(e):e;return t.forEach(function(f){u[f]=!e[f]}),u},$unset:function(t,e,u,f){return g(t,"$unset"),t.forEach(function(a){Object.hasOwnProperty.call(e,a)&&(e===f&&(e=y(f)),delete e[a])}),e},$add:function(t,e,u,f){return U(e,"$add"),g(t,"$add"),v(e)==="Map"?t.forEach(function(a){var m=a[0],w=a[1];e===f&&e.get(m)!==w&&(e=y(f)),e.set(m,w)}):t.forEach(function(a){e===f&&!e.has(a)&&(e=y(f)),e.add(a)}),e},$remove:function(t,e,u,f){return U(e,"$remove"),g(t,"$remove"),t.forEach(function(a){e===f&&e.has(a)&&(e=y(f)),e.delete(a)}),e},$merge:function(t,e,u,f){return Y(e,t),s(t).forEach(function(a){t[a]!==e[a]&&(e===f&&(e=y(f)),e[a]=t[a])}),e},$apply:function(t,e){return D(t),t(e)}},E=new A;n.isEquals=E.update.isEquals,n.extend=E.extend,n.default=E.update,n.default.default=r.exports=$(n.default,n);function p(t,e,u){o(Array.isArray(t),function(){return"update(): expected target of "+i(u)+" to be an array; got "+i(t)+"."}),g(e[u],u)}function g(t,e){o(Array.isArray(t),function(){return"update(): expected spec of "+i(e)+" to be an array; got "+i(t)+". Did you forget to wrap your parameter in an array?"})}function l(t,e){o(Array.isArray(t),function(){return"Expected $splice target to be an array; got "+i(t)}),_(e.$splice)}function _(t){o(Array.isArray(t),function(){return"update(): expected spec of $splice to be an array of arrays; got "+i(t)+". Did you forget to wrap your parameters in an array?"})}function D(t){o(typeof t=="function",function(){return"update(): expected spec of $apply to be a function; got "+i(t)+"."})}function X(t){o(Object.keys(t).length===1,function(){return"Cannot have more than one key in an object with $set"})}function Y(t,e){o(e&&typeof e=="object",function(){return"update(): $merge expects a spec of type 'object'; got "+i(e)}),o(t&&typeof t=="object",function(){return"update(): $merge expects a target of type 'object'; got "+i(t)})}function U(t,e){var u=v(t);o(u==="Map"||u==="Set",function(){return"update(): "+i(e)+" expects a target of type Set or Map; got "+i(u)})}})(N,N.exports);var Tt=N.exports;const W=B(Tt),Ct=r=>({map:{tileType:"cycle"},kml:void 0,changeMapType(n){r(i=>W(i,{map:{tileType:{$set:n}}}))},storeKML(n){r(i=>W(i,{kml:{$set:n}}))}}),Mt=_t()(At(Ct));export{Mt as u};
