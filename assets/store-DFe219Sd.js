import{r as k,g as K,R as tt}from"./index-D5qa_RYa.js";const et={},V=n=>{let o;const r=new Set,h=(i,u)=>{const f=typeof i=="function"?i(o):i;if(!Object.is(f,o)){const p=o;o=u??(typeof f!="object"||f===null)?f:Object.assign({},o,f),r.forEach(g=>g(o,p))}},a=()=>o,m={setState:h,getState:a,getInitialState:()=>E,subscribe:i=>(r.add(i),()=>r.delete(i)),destroy:()=>{(et?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),r.clear()}},E=o=n(h,a,m);return m},nt=n=>n?V(n):V;var q={exports:{}},O={},U={exports:{}},z={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var H;function rt(){if(H)return z;H=1;var n=k();function o(u,f){return u===f&&(u!==0||1/u===1/f)||u!==u&&f!==f}var r=typeof Object.is=="function"?Object.is:o,h=n.useState,a=n.useEffect,A=n.useLayoutEffect,R=n.useDebugValue;function S(u,f){var p=f(),g=h({inst:{value:p,getSnapshot:f}}),s=g[0].inst,y=g[1];return A(function(){s.value=p,s.getSnapshot=f,m(s)&&y({inst:s})},[u,p,f]),a(function(){return m(s)&&y({inst:s}),u(function(){m(s)&&y({inst:s})})},[u]),R(p),p}function m(u){var f=u.getSnapshot;u=u.value;try{var p=f();return!r(u,p)}catch{return!0}}function E(u,f){return f()}var i=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?E:S;return z.useSyncExternalStore=n.useSyncExternalStore!==void 0?n.useSyncExternalStore:i,z}var F;function ot(){return F||(F=1,U.exports=rt()),U.exports}/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var B;function it(){if(B)return O;B=1;var n=k(),o=ot();function r(E,i){return E===i&&(E!==0||1/E===1/i)||E!==E&&i!==i}var h=typeof Object.is=="function"?Object.is:r,a=o.useSyncExternalStore,A=n.useRef,R=n.useEffect,S=n.useMemo,m=n.useDebugValue;return O.useSyncExternalStoreWithSelector=function(E,i,u,f,p){var g=A(null);if(g.current===null){var s={hasValue:!1,value:null};g.current=s}else s=g.current;g=S(function(){function l(T){if(!_){if(_=!0,C=T,T=f(T),p!==void 0&&s.hasValue){var t=s.value;if(p(t,T))return b=t}return b=T}if(t=b,h(C,T))return t;var e=f(T);return p!==void 0&&p(t,e)?(C=T,t):(C=T,b=e)}var _=!1,C,b,D=u===void 0?null:u;return[function(){return l(i())},D===null?void 0:function(){return l(D())}]},[i,u,f,p]);var y=a(E,g[0],g[1]);return R(function(){s.hasValue=!0,s.value=y},[y]),m(y),y},O}var G;function at(){return G||(G=1,q.exports=it()),q.exports}var ut=at();const st=K(ut),Q={},{useDebugValue:ct}=tt,{useSyncExternalStoreWithSelector:ft}=st;let X=!1;const dt=n=>n;function lt(n,o=dt,r){(Q?"production":void 0)!=="production"&&r&&!X&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),X=!0);const h=ft(n.subscribe,n.getState,n.getServerState||n.getInitialState,o,r);return ct(h),h}const Y=n=>{(Q?"production":void 0)!=="production"&&typeof n!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const o=typeof n=="function"?nt(n):n,r=(h,a)=>lt(o,h,a);return Object.assign(r,o),r},pt=n=>n?Y(n):Y,W={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1},L=new Map,M=n=>{const o=L.get(n);return o?Object.fromEntries(Object.entries(o.stores).map(([r,h])=>[r,h.getState()])):{}},vt=(n,o,r)=>{if(n===void 0)return{type:"untracked",connection:o.connect(r)};const h=L.get(r.name);if(h)return{type:"tracked",store:n,...h};const a={connection:o.connect(r),stores:{}};return L.set(r.name,a),{type:"tracked",store:n,...a}},yt=(n,o={})=>(r,h,a)=>{const{enabled:A,anonymousActionType:R,store:S,...m}=o;let E;try{E=(A??(W?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!E)return(W?"production":void 0)!=="production"&&A&&console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension"),n(r,h,a);const{connection:i,...u}=vt(S,E,m);let f=!0;a.setState=(s,y,l)=>{const _=r(s,y);if(!f)return _;const C=l===void 0?{type:R||"anonymous"}:typeof l=="string"?{type:l}:l;return S===void 0?(i==null||i.send(C,h()),_):(i==null||i.send({...C,type:`${S}/${C.type}`},{...M(m.name),[S]:a.getState()}),_)};const p=(...s)=>{const y=f;f=!1,r(...s),f=y},g=n(a.setState,h,a);if(u.type==="untracked"?i==null||i.init(g):(u.stores[u.store]=a,i==null||i.init(Object.fromEntries(Object.entries(u.stores).map(([s,y])=>[s,s===u.store?g:y.getState()])))),a.dispatchFromDevtools&&typeof a.dispatch=="function"){let s=!1;const y=a.dispatch;a.dispatch=(...l)=>{(W?"production":void 0)!=="production"&&l[0].type==="__setState"&&!s&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),s=!0),y(...l)}}return i.subscribe(s=>{var y;switch(s.type){case"ACTION":if(typeof s.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return N(s.payload,l=>{if(l.type==="__setState"){if(S===void 0){p(l.state);return}Object.keys(l.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const _=l.state[S];if(_==null)return;JSON.stringify(a.getState())!==JSON.stringify(_)&&p(_);return}a.dispatchFromDevtools&&typeof a.dispatch=="function"&&a.dispatch(l)});case"DISPATCH":switch(s.payload.type){case"RESET":return p(g),S===void 0?i==null?void 0:i.init(a.getState()):i==null?void 0:i.init(M(m.name));case"COMMIT":if(S===void 0){i==null||i.init(a.getState());return}return i==null?void 0:i.init(M(m.name));case"ROLLBACK":return N(s.state,l=>{if(S===void 0){p(l),i==null||i.init(a.getState());return}p(l[S]),i==null||i.init(M(m.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return N(s.state,l=>{if(S===void 0){p(l);return}JSON.stringify(a.getState())!==JSON.stringify(l[S])&&p(l[S])});case"IMPORT_STATE":{const{nextLiftedState:l}=s.payload,_=(y=l.computedStates.slice(-1)[0])==null?void 0:y.state;if(!_)return;p(S===void 0?_:_[S]),i==null||i.send(null,l);return}case"PAUSE_RECORDING":return f=!f}return}}),g},ht=yt,N=(n,o)=>{let r;try{r=JSON.parse(n)}catch(h){console.error("[zustand devtools middleware] Could not parse the received json",h)}r!==void 0&&o(r)};var P={exports:{}},x;function St(){return x||(x=1,function(n,o){Object.defineProperty(o,"__esModule",{value:!0});function r(t){return typeof t=="object"&&!("toString"in t)?Object.prototype.toString.call(t).slice(8,-1):t}var h=typeof process=="object"&&!0;function a(t,e){if(!t)throw h?new Error("Invariant failed"):new Error(e())}o.invariant=a;var A=Object.prototype.hasOwnProperty,R=Array.prototype.splice,S=Object.prototype.toString;function m(t){return S.call(t).slice(8,-1)}var E=Object.assign||function(t,e){return i(e).forEach(function(c){A.call(e,c)&&(t[c]=e[c])}),t},i=typeof Object.getOwnPropertySymbols=="function"?function(t){return Object.keys(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.keys(t)};function u(t){return Array.isArray(t)?E(t.constructor(t.length),t):m(t)==="Map"?new Map(t):m(t)==="Set"?new Set(t):t&&typeof t=="object"?E(Object.create(Object.getPrototypeOf(t)),t):t}var f=function(){function t(){this.commands=E({},p),this.update=this.update.bind(this),this.update.extend=this.extend=this.extend.bind(this),this.update.isEquals=function(e,c){return e===c},this.update.newContext=function(){return new t().update}}return Object.defineProperty(t.prototype,"isEquals",{get:function(){return this.update.isEquals},set:function(e){this.update.isEquals=e},enumerable:!0,configurable:!0}),t.prototype.extend=function(e,c){this.commands[e]=c},t.prototype.update=function(e,c){var v=this,d=typeof c=="function"?{$apply:c}:c;Array.isArray(e)&&Array.isArray(d)||a(!Array.isArray(d),function(){return"update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value."}),a(typeof d=="object"&&d!==null,function(){return"update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the "+("following commands: "+Object.keys(v.commands).join(", ")+".")});var w=e;return i(d).forEach(function($){if(A.call(v.commands,$)){var Z=e===w;w=v.commands[$](d[$],w,d,e),Z&&v.isEquals(w,e)&&(w=e)}else{var I=m(e)==="Map"?v.update(e.get($),d[$]):v.update(e[$],d[$]),j=m(w)==="Map"?w.get($):w[$];(!v.isEquals(I,j)||typeof I>"u"&&!A.call(e,$))&&(w===e&&(w=u(e)),m(w)==="Map"?w.set($,I):w[$]=I)}}),w},t}();o.Context=f;var p={$push:function(t,e,c){return s(e,c,"$push"),t.length?e.concat(t):e},$unshift:function(t,e,c){return s(e,c,"$unshift"),t.length?t.concat(e):e},$splice:function(t,e,c,v){return l(e,c),t.forEach(function(d){_(d),e===v&&d.length&&(e=u(v)),R.apply(e,d)}),e},$set:function(t,e,c){return b(c),t},$toggle:function(t,e){y(t,"$toggle");var c=t.length?u(e):e;return t.forEach(function(v){c[v]=!e[v]}),c},$unset:function(t,e,c,v){return y(t,"$unset"),t.forEach(function(d){Object.hasOwnProperty.call(e,d)&&(e===v&&(e=u(v)),delete e[d])}),e},$add:function(t,e,c,v){return T(e,"$add"),y(t,"$add"),m(e)==="Map"?t.forEach(function(d){var w=d[0],$=d[1];e===v&&e.get(w)!==$&&(e=u(v)),e.set(w,$)}):t.forEach(function(d){e===v&&!e.has(d)&&(e=u(v)),e.add(d)}),e},$remove:function(t,e,c,v){return T(e,"$remove"),y(t,"$remove"),t.forEach(function(d){e===v&&e.has(d)&&(e=u(v)),e.delete(d)}),e},$merge:function(t,e,c,v){return D(e,t),i(t).forEach(function(d){t[d]!==e[d]&&(e===v&&(e=u(v)),e[d]=t[d])}),e},$apply:function(t,e){return C(t),t(e)}},g=new f;o.isEquals=g.update.isEquals,o.extend=g.extend,o.default=g.update,o.default.default=n.exports=E(o.default,o);function s(t,e,c){a(Array.isArray(t),function(){return"update(): expected target of "+r(c)+" to be an array; got "+r(t)+"."}),y(e[c],c)}function y(t,e){a(Array.isArray(t),function(){return"update(): expected spec of "+r(e)+" to be an array; got "+r(t)+". Did you forget to wrap your parameter in an array?"})}function l(t,e){a(Array.isArray(t),function(){return"Expected $splice target to be an array; got "+r(t)}),_(e.$splice)}function _(t){a(Array.isArray(t),function(){return"update(): expected spec of $splice to be an array of arrays; got "+r(t)+". Did you forget to wrap your parameters in an array?"})}function C(t){a(typeof t=="function",function(){return"update(): expected spec of $apply to be a function; got "+r(t)+"."})}function b(t){a(Object.keys(t).length===1,function(){return"Cannot have more than one key in an object with $set"})}function D(t,e){a(e&&typeof e=="object",function(){return"update(): $merge expects a spec of type 'object'; got "+r(e)}),a(t&&typeof t=="object",function(){return"update(): $merge expects a target of type 'object'; got "+r(t)})}function T(t,e){var c=m(t);a(c==="Map"||c==="Set",function(){return"update(): "+r(e)+" expects a target of type Set or Map; got "+r(c)})}}(P,P.exports)),P.exports}var mt=St();const J=K(mt),gt=n=>({settings:{mapTileType:"atlas",elevationChartVisible:!0},kml:void 0,setMapTileType(o){n(r=>J(r,{settings:{mapTileType:{$set:o}}}))},toggleElevationChart(){n(o=>J(o,{settings:{elevationChartVisible:{$set:!o.settings.elevationChartVisible}}}))},storeKML(o){n(r=>J(r,{kml:{$set:o}}))}}),_t=pt()(ht(gt));export{_t as u};
