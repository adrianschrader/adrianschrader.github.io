import{b as k,g as K,R as tt}from"./index-C8h-BEVG.js";const et={},L=n=>{let u;const r=new Set,h=(o,a)=>{const f=typeof o=="function"?o(u):o;if(!Object.is(f,u)){const p=u;u=a??(typeof f!="object"||f===null)?f:Object.assign({},u,f),r.forEach(g=>g(u,p))}},i=()=>u,m={setState:h,getState:i,getInitialState:()=>E,subscribe:o=>(r.add(o),()=>r.delete(o)),destroy:()=>{(et?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),r.clear()}},E=u=n(h,i,m);return m},nt=n=>n?L(n):L;var q={exports:{}},O={},U={exports:{}},z={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var H;function rt(){if(H)return z;H=1;var n=k();function u(a,f){return a===f&&(a!==0||1/a===1/f)||a!==a&&f!==f}var r=typeof Object.is=="function"?Object.is:u,h=n.useState,i=n.useEffect,A=n.useLayoutEffect,C=n.useDebugValue;function S(a,f){var p=f(),g=h({inst:{value:p,getSnapshot:f}}),s=g[0].inst,v=g[1];return A(function(){s.value=p,s.getSnapshot=f,m(s)&&v({inst:s})},[a,p,f]),i(function(){return m(s)&&v({inst:s}),a(function(){m(s)&&v({inst:s})})},[a]),C(p),p}function m(a){var f=a.getSnapshot;a=a.value;try{var p=f();return!r(a,p)}catch{return!0}}function E(a,f){return f()}var o=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?E:S;return z.useSyncExternalStore=n.useSyncExternalStore!==void 0?n.useSyncExternalStore:o,z}var V;function ot(){return V||(V=1,U.exports=rt()),U.exports}/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var F;function it(){if(F)return O;F=1;var n=k(),u=ot();function r(E,o){return E===o&&(E!==0||1/E===1/o)||E!==E&&o!==o}var h=typeof Object.is=="function"?Object.is:r,i=u.useSyncExternalStore,A=n.useRef,C=n.useEffect,S=n.useMemo,m=n.useDebugValue;return O.useSyncExternalStoreWithSelector=function(E,o,a,f,p){var g=A(null);if(g.current===null){var s={hasValue:!1,value:null};g.current=s}else s=g.current;g=S(function(){function l(R){if(!_){if(_=!0,T=R,R=f(R),p!==void 0&&s.hasValue){var t=s.value;if(p(t,R))return D=t}return D=R}if(t=D,h(T,R))return t;var e=f(R);return p!==void 0&&p(t,e)?(T=R,t):(T=R,D=e)}var _=!1,T,D,b=a===void 0?null:a;return[function(){return l(o())},b===null?void 0:function(){return l(b())}]},[o,a,f,p]);var v=i(E,g[0],g[1]);return C(function(){s.hasValue=!0,s.value=v},[v]),m(v),v},O}var B;function ut(){return B||(B=1,q.exports=it()),q.exports}var at=ut();const st=K(at),Q={},{useDebugValue:ct}=tt,{useSyncExternalStoreWithSelector:ft}=st;let G=!1;const dt=n=>n;function lt(n,u=dt,r){(Q?"production":void 0)!=="production"&&r&&!G&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),G=!0);const h=ft(n.subscribe,n.getState,n.getServerState||n.getInitialState,u,r);return ct(h),h}const X=n=>{(Q?"production":void 0)!=="production"&&typeof n!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const u=typeof n=="function"?nt(n):n,r=(h,i)=>lt(u,h,i);return Object.assign(r,u),r},pt=n=>n?X(n):X,W={BASE_URL:"/",DEV:!1,MODE:"production",PROD:!0,SSR:!1},J=new Map,M=n=>{const u=J.get(n);return u?Object.fromEntries(Object.entries(u.stores).map(([r,h])=>[r,h.getState()])):{}},yt=(n,u,r)=>{if(n===void 0)return{type:"untracked",connection:u.connect(r)};const h=J.get(r.name);if(h)return{type:"tracked",store:n,...h};const i={connection:u.connect(r),stores:{}};return J.set(r.name,i),{type:"tracked",store:n,...i}},vt=(n,u={})=>(r,h,i)=>{const{enabled:A,anonymousActionType:C,store:S,...m}=u;let E;try{E=(A??(W?"production":void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!E)return(W?"production":void 0)!=="production"&&A&&console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension"),n(r,h,i);const{connection:o,...a}=yt(S,E,m);let f=!0;i.setState=(s,v,l)=>{const _=r(s,v);if(!f)return _;const T=l===void 0?{type:C||"anonymous"}:typeof l=="string"?{type:l}:l;return S===void 0?(o==null||o.send(T,h()),_):(o==null||o.send({...T,type:`${S}/${T.type}`},{...M(m.name),[S]:i.getState()}),_)};const p=(...s)=>{const v=f;f=!1,r(...s),f=v},g=n(i.setState,h,i);if(a.type==="untracked"?o==null||o.init(g):(a.stores[a.store]=i,o==null||o.init(Object.fromEntries(Object.entries(a.stores).map(([s,v])=>[s,s===a.store?g:v.getState()])))),i.dispatchFromDevtools&&typeof i.dispatch=="function"){let s=!1;const v=i.dispatch;i.dispatch=(...l)=>{(W?"production":void 0)!=="production"&&l[0].type==="__setState"&&!s&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),s=!0),v(...l)}}return o.subscribe(s=>{var v;switch(s.type){case"ACTION":if(typeof s.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return N(s.payload,l=>{if(l.type==="__setState"){if(S===void 0){p(l.state);return}Object.keys(l.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);const _=l.state[S];if(_==null)return;JSON.stringify(i.getState())!==JSON.stringify(_)&&p(_);return}i.dispatchFromDevtools&&typeof i.dispatch=="function"&&i.dispatch(l)});case"DISPATCH":switch(s.payload.type){case"RESET":return p(g),S===void 0?o==null?void 0:o.init(i.getState()):o==null?void 0:o.init(M(m.name));case"COMMIT":if(S===void 0){o==null||o.init(i.getState());return}return o==null?void 0:o.init(M(m.name));case"ROLLBACK":return N(s.state,l=>{if(S===void 0){p(l),o==null||o.init(i.getState());return}p(l[S]),o==null||o.init(M(m.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return N(s.state,l=>{if(S===void 0){p(l);return}JSON.stringify(i.getState())!==JSON.stringify(l[S])&&p(l[S])});case"IMPORT_STATE":{const{nextLiftedState:l}=s.payload,_=(v=l.computedStates.slice(-1)[0])==null?void 0:v.state;if(!_)return;p(S===void 0?_:_[S]),o==null||o.send(null,l);return}case"PAUSE_RECORDING":return f=!f}return}}),g},ht=vt,N=(n,u)=>{let r;try{r=JSON.parse(n)}catch(h){console.error("[zustand devtools middleware] Could not parse the received json",h)}r!==void 0&&u(r)};var P={exports:{}},Y;function St(){return Y||(Y=1,function(n,u){Object.defineProperty(u,"__esModule",{value:!0});function r(t){return typeof t=="object"&&!("toString"in t)?Object.prototype.toString.call(t).slice(8,-1):t}var h=typeof process=="object"&&!0;function i(t,e){if(!t)throw h?new Error("Invariant failed"):new Error(e())}u.invariant=i;var A=Object.prototype.hasOwnProperty,C=Array.prototype.splice,S=Object.prototype.toString;function m(t){return S.call(t).slice(8,-1)}var E=Object.assign||function(t,e){return o(e).forEach(function(c){A.call(e,c)&&(t[c]=e[c])}),t},o=typeof Object.getOwnPropertySymbols=="function"?function(t){return Object.keys(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.keys(t)};function a(t){return Array.isArray(t)?E(t.constructor(t.length),t):m(t)==="Map"?new Map(t):m(t)==="Set"?new Set(t):t&&typeof t=="object"?E(Object.create(Object.getPrototypeOf(t)),t):t}var f=function(){function t(){this.commands=E({},p),this.update=this.update.bind(this),this.update.extend=this.extend=this.extend.bind(this),this.update.isEquals=function(e,c){return e===c},this.update.newContext=function(){return new t().update}}return Object.defineProperty(t.prototype,"isEquals",{get:function(){return this.update.isEquals},set:function(e){this.update.isEquals=e},enumerable:!0,configurable:!0}),t.prototype.extend=function(e,c){this.commands[e]=c},t.prototype.update=function(e,c){var y=this,d=typeof c=="function"?{$apply:c}:c;Array.isArray(e)&&Array.isArray(d)||i(!Array.isArray(d),function(){return"update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value."}),i(typeof d=="object"&&d!==null,function(){return"update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the "+("following commands: "+Object.keys(y.commands).join(", ")+".")});var w=e;return o(d).forEach(function($){if(A.call(y.commands,$)){var Z=e===w;w=y.commands[$](d[$],w,d,e),Z&&y.isEquals(w,e)&&(w=e)}else{var I=m(e)==="Map"?y.update(e.get($),d[$]):y.update(e[$],d[$]),j=m(w)==="Map"?w.get($):w[$];(!y.isEquals(I,j)||typeof I>"u"&&!A.call(e,$))&&(w===e&&(w=a(e)),m(w)==="Map"?w.set($,I):w[$]=I)}}),w},t}();u.Context=f;var p={$push:function(t,e,c){return s(e,c,"$push"),t.length?e.concat(t):e},$unshift:function(t,e,c){return s(e,c,"$unshift"),t.length?t.concat(e):e},$splice:function(t,e,c,y){return l(e,c),t.forEach(function(d){_(d),e===y&&d.length&&(e=a(y)),C.apply(e,d)}),e},$set:function(t,e,c){return D(c),t},$toggle:function(t,e){v(t,"$toggle");var c=t.length?a(e):e;return t.forEach(function(y){c[y]=!e[y]}),c},$unset:function(t,e,c,y){return v(t,"$unset"),t.forEach(function(d){Object.hasOwnProperty.call(e,d)&&(e===y&&(e=a(y)),delete e[d])}),e},$add:function(t,e,c,y){return R(e,"$add"),v(t,"$add"),m(e)==="Map"?t.forEach(function(d){var w=d[0],$=d[1];e===y&&e.get(w)!==$&&(e=a(y)),e.set(w,$)}):t.forEach(function(d){e===y&&!e.has(d)&&(e=a(y)),e.add(d)}),e},$remove:function(t,e,c,y){return R(e,"$remove"),v(t,"$remove"),t.forEach(function(d){e===y&&e.has(d)&&(e=a(y)),e.delete(d)}),e},$merge:function(t,e,c,y){return b(e,t),o(t).forEach(function(d){t[d]!==e[d]&&(e===y&&(e=a(y)),e[d]=t[d])}),e},$apply:function(t,e){return T(t),t(e)}},g=new f;u.isEquals=g.update.isEquals,u.extend=g.extend,u.default=g.update,u.default.default=n.exports=E(u.default,u);function s(t,e,c){i(Array.isArray(t),function(){return"update(): expected target of "+r(c)+" to be an array; got "+r(t)+"."}),v(e[c],c)}function v(t,e){i(Array.isArray(t),function(){return"update(): expected spec of "+r(e)+" to be an array; got "+r(t)+". Did you forget to wrap your parameter in an array?"})}function l(t,e){i(Array.isArray(t),function(){return"Expected $splice target to be an array; got "+r(t)}),_(e.$splice)}function _(t){i(Array.isArray(t),function(){return"update(): expected spec of $splice to be an array of arrays; got "+r(t)+". Did you forget to wrap your parameters in an array?"})}function T(t){i(typeof t=="function",function(){return"update(): expected spec of $apply to be a function; got "+r(t)+"."})}function D(t){i(Object.keys(t).length===1,function(){return"Cannot have more than one key in an object with $set"})}function b(t,e){i(e&&typeof e=="object",function(){return"update(): $merge expects a spec of type 'object'; got "+r(e)}),i(t&&typeof t=="object",function(){return"update(): $merge expects a target of type 'object'; got "+r(t)})}function R(t,e){var c=m(t);i(c==="Map"||c==="Set",function(){return"update(): "+r(e)+" expects a target of type Set or Map; got "+r(c)})}}(P,P.exports)),P.exports}var mt=St();const x=K(mt),gt=n=>({map:{tileType:"cycle"},kml:void 0,changeMapType(u){n(r=>x(r,{map:{tileType:{$set:u}}}))},storeKML(u){n(r=>x(r,{kml:{$set:u}}))}}),_t=pt()(ht(gt));export{_t as u};
